/**
 * Automatic Measurement and CAD Detection Overlay Component
 * Combines AI-powered automatic measurements with Computer-Aided Detection (CAD) overlays
 */

import React, { useEffect, useState, useRef, useCallback } from 'react';
import {
  Box,
  Paper,
  Typography,
  IconButton,
  Tooltip,
  Chip,
  Switch,
  FormControlLabel,
  Slider,
  Divider,
  List,
  ListItem,
  ListItemText,
  ListItemSecondaryAction,
  Badge,
  Menu,
  MenuItem,
  Button,
  Alert
} from '@mui/material';
import {
  Straighten as RulerIcon,
  RadioButtonUnchecked as CircleIcon,
  Timeline as AngleIcon,
  Visibility,
  VisibilityOff,
  Settings,
  Warning,
  Error,
  Info,
  CheckCircle,
  AutoFixHigh,
  Calculate,
  Delete as DeleteIcon,
  Refresh as RefreshIcon
} from '@mui/icons-material';
import { MeasurementTools, Measurement, ImageCalibration } from '../../services/measurementTools';
import { DetectionResult } from '../../services/aiEnhancementModule';
import { DetectionOverlay } from '../../services/abnormalityDetectionService';

export interface AutoMeasurementCADOverlayProps {
  imageId: string;
  containerRef: React.RefObject<HTMLElement>;
  calibration: ImageCalibration;
  detectionResults?: DetectionResult[];
  onMeasurementAdd?: (measurement: Measurement) => void;
  onMeasurementDelete?: (id: string) => void;
  onDetectionClick?: (detection: DetectionResult) => void;
  autoMeasureEnabled?: boolean;
  cadOverlayEnabled?: boolean;
  className?: string;
}

interface AutoMeasurementSettings {
  enabled: boolean;
  confidence: number;
  measurementTypes: {
    distance: boolean;
    area: boolean;
    angle: boolean;
  };
  autoValidate: boolean;
}

interface CADOverlaySettings {
  enabled: boolean;
  opacity: number;
  showLabels: boolean;
  showConfidence: boolean;
  minConfidence: number;
}

/**
 * Component that provides automatic measurements and CAD detection overlays
 */
export const AutoMeasurementCADOverlay: React.FC<AutoMeasurementCADOverlayProps> = ({
  imageId,
  containerRef,
  calibration,
  detectionResults = [],
  onMeasurementAdd,
  onMeasurementDelete,
  onDetectionClick,
  autoMeasureEnabled = false,
  cadOverlayEnabled = true,
  className
}) => {
  const [measurementTools] = useState(() => new MeasurementTools());
  const [measurements, setMeasurements] = useState<Measurement[]>([]);
  const [autoMeasurements, setAutoMeasurements] = useState<Measurement[]>([]);
  const [settingsAnchor, setSettingsAnchor] = useState<null | HTMLElement>(null);
  const [hoveredDetection, setHoveredDetection] = useState<string | null>(null);
  const overlayRef = useRef<HTMLDivElement>(null);
  
  const [autoMeasureSettings, setAutoMeasureSettings] = useState<AutoMeasurementSettings>({
    enabled: autoMeasureEnabled,
    confidence: 0.8,
    measurementTypes: {
      distance: true,
      area: true,
      angle: false
    },
    autoValidate: false
  });

  const [cadSettings, setCadSettings] = useState<CADOverlaySettings>({
    enabled: cadOverlayEnabled,
    opacity: 0.7,
    showLabels: true,
    showConfidence: true,
    minConfidence: 0.5
  });

  // Initialize measurement session
  useEffect(() => {
    if (imageId && calibration) {
      const session = measurementTools.createSession(imageId, calibration, 'auto-system');
      measurementTools.setActiveSession(session.id);
    }
  }, [imageId, calibration, measurementTools]);

  // Auto-generate measurements from detection results
  const generateAutoMeasurements = useCallback(async () => {
    if (!autoMeasureSettings.enabled || !detectionResults.length) return;

    const newAutoMeasurements: Measurement[] = [];

    for (const detection of detectionResults) {
      if (detection.confidence < autoMeasureSettings.confidence) continue;

      try {
        // Generate distance measurements for nodules/lesions
        if (autoMeasureSettings.measurementTypes.distance && detection.boundingBox) {
          const { x, y, width, height } = detection.boundingBox;
          const startPoint = { x, y };
          const endPoint = { x: x + width, y: y + height };
          
          const measurement = measurementTools.createDistanceMeasurement(
            startPoint,
            endPoint,
            detection.class === 'nodule' ? 'lung-nodule-diameter' : undefined,
            `Auto: ${detection.class} diameter`
          );
          
          measurement.metadata.autoGenerated = true;
          measurement.metadata.detectionId = detection.id;
          measurement.metadata.confidence = detection.confidence;
          
          newAutoMeasurements.push(measurement);
        }

        // Generate area measurements for larger abnormalities
        if (autoMeasureSettings.measurementTypes.area && detection.contour && detection.contour.length >= 3) {
          const measurement = measurementTools.createAreaMeasurement(
            detection.contour,
            'polygon',
            undefined,
            `Auto: ${detection.class} area`
          );
          
          measurement.metadata.autoGenerated = true;
          measurement.metadata.detectionId = detection.id;
          measurement.metadata.confidence = detection.confidence;
          
          newAutoMeasurements.push(measurement);
        }

      } catch (error) {
        console.error('Error generating auto measurement:', error);
      }
    }

    setAutoMeasurements(newAutoMeasurements);
    
    // Notify parent component
    newAutoMeasurements.forEach(measurement => {
      onMeasurementAdd?.(measurement);
    });

  }, [detectionResults, autoMeasureSettings, measurementTools, onMeasurementAdd]);

  // Trigger auto measurements when detection results change
  useEffect(() => {
    if (autoMeasureSettings.enabled) {
      generateAutoMeasurements();
    }
  }, [detectionResults, autoMeasureSettings.enabled, generateAutoMeasurements]);

  // Update overlay position
  useEffect(() => {
    const updateOverlayPosition = () => {
      if (overlayRef.current && containerRef.current) {
        const containerRect = containerRef.current.getBoundingClientRect();
        const overlayElement = overlayRef.current;
        
        overlayElement.style.position = 'absolute';
        overlayElement.style.top = '0';
        overlayElement.style.left = '0';
        overlayElement.style.width = '100%';
        overlayElement.style.height = '100%';
        overlayElement.style.pointerEvents = 'none';
        overlayElement.style.zIndex = '10';
      }
    };

    updateOverlayPosition();
    
    const resizeObserver = new ResizeObserver(updateOverlayPosition);
    if (containerRef.current) {
      resizeObserver.observe(containerRef.current);
    }

    return () => {
      resizeObserver.disconnect();
    };
  }, [containerRef]);

  const getSeverityIcon = (severity: DetectionResult['severity']) => {
    switch (severity) {
      case 'critical':
        return <Error color="error" fontSize="small" />;
      case 'high':
        return <Warning color="warning" fontSize="small" />;
      case 'medium':
        return <Info color="info" fontSize="small" />;
      case 'low':
        return <CheckCircle color="success" fontSize="small" />;
      default:
        return <Info color="info" fontSize="small" />;
    }
  };

  const getSeverityColor = (severity: DetectionResult['severity']) => {
    switch (severity) {
      case 'critical': return '#f44336';
      case 'high': return '#ff9800';
      case 'medium': return '#2196f3';
      case 'low': return '#4caf50';
      default: return '#9e9e9e';
    }
  };

  const handleDetectionClick = (detection: DetectionResult) => {
    onDetectionClick?.(detection);
  };

  const handleMeasurementDelete = (measurementId: string) => {
    measurementTools.deleteMeasurement(measurementId);
    setAutoMeasurements(prev => prev.filter(m => m.id !== measurementId));
    onMeasurementDelete?.(measurementId);
  };

  const handleSettingsClick = (event: React.MouseEvent<HTMLElement>) => {
    setSettingsAnchor(event.currentTarget);
  };

  const handleSettingsClose = () => {
    setSettingsAnchor(null);
  };

  const filteredDetections = detectionResults.filter(
    detection => detection.confidence >= cadSettings.minConfidence
  );

  return (
    <Box className={className}>
      {/* Overlay Canvas */}
      <div
        ref={overlayRef}
        style={{
          position: 'absolute',
          top: 0,
          left: 0,
          width: '100%',
          height: '100%',
          pointerEvents: 'none',
          zIndex: 10
        }}
      >
        {/* CAD Detection Overlays */}
        {cadSettings.enabled && filteredDetections.map((detection) => (
          <Box
            key={detection.id}
            sx={{
              position: 'absolute',
              left: detection.boundingBox?.x || 0,
              top: detection.boundingBox?.y || 0,
              width: detection.boundingBox?.width || 0,
              height: detection.boundingBox?.height || 0,
              border: `2px solid ${getSeverityColor(detection.severity)}`,
              borderRadius: 1,
              backgroundColor: `${getSeverityColor(detection.severity)}20`,
              opacity: cadSettings.opacity,
              pointerEvents: 'auto',
              cursor: 'pointer',
              transition: 'all 0.2s ease',
              '&:hover': {
                opacity: 1,
                transform: 'scale(1.02)'
              }
            }}
            onClick={() => handleDetectionClick(detection)}
            onMouseEnter={() => setHoveredDetection(detection.id)}
            onMouseLeave={() => setHoveredDetection(null)}
          >
            {/* Detection Label */}
            {cadSettings.showLabels && (
              <Chip
                size="small"
                icon={getSeverityIcon(detection.severity)}
                label={
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                    <Typography variant="caption">
                      {detection.class}
                    </Typography>
                    {cadSettings.showConfidence && (
                      <Typography variant="caption" sx={{ opacity: 0.8 }}>
                        ({Math.round(detection.confidence * 100)}%)
                      </Typography>
                    )}
                  </Box>
                }
                sx={{
                  position: 'absolute',
                  top: -8,
                  left: -1,
                  backgroundColor: getSeverityColor(detection.severity),
                  color: 'white',
                  fontSize: '0.7rem',
                  height: 20
                }}
              />
            )}
          </Box>
        ))}

        {/* Auto Measurement Overlays */}
        {autoMeasureSettings.enabled && autoMeasurements.map((measurement) => (
          <Box
            key={measurement.id}
            sx={{
              position: 'absolute',
              pointerEvents: 'auto'
            }}
          >
            {/* Render measurement based on type */}
            {measurement.type === 'distance' && measurement.points.length >= 2 && (
              <svg
                style={{
                  position: 'absolute',
                  width: '100%',
                  height: '100%',
                  pointerEvents: 'none'
                }}
              >
                <line
                  x1={measurement.points[0].position.x}
                  y1={measurement.points[0].position.y}
                  x2={measurement.points[1].position.x}
                  y2={measurement.points[1].position.y}
                  stroke={measurement.style.color}
                  strokeWidth={measurement.style.lineWidth}
                  strokeDasharray={measurement.style.dashPattern?.join(' ')}
                />
                <text
                  x={(measurement.points[0].position.x + measurement.points[1].position.x) / 2}
                  y={(measurement.points[0].position.y + measurement.points[1].position.y) / 2 - 5}
                  fill={measurement.style.color}
                  fontSize={measurement.style.fontSize}
                  textAnchor="middle"
                >
                  {measurement.value.toFixed(1)} {measurement.unit}
                </text>
              </svg>
            )}
          </Box>
        ))}
      </div>

      {/* Control Panel */}
      <Paper
        elevation={3}
        sx={{
          position: 'absolute',
          top: 16,
          right: 16,
          p: 2,
          minWidth: 280,
          maxHeight: '60vh',
          overflow: 'auto',
          zIndex: 20
        }}
      >
        <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', mb: 2 }}>
          <Typography variant="h6" sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
            <AutoFixHigh color="primary" />
            Auto Measurements & CAD
          </Typography>
          <IconButton size="small" onClick={handleSettingsClick}>
            <Settings />
          </IconButton>
        </Box>

        {/* Auto Measurements Section */}
        <Box sx={{ mb: 2 }}>
          <FormControlLabel
            control={
              <Switch
                checked={autoMeasureSettings.enabled}
                onChange={(e) => setAutoMeasureSettings(prev => ({
                  ...prev,
                  enabled: e.target.checked
                }))}
              />
            }
            label="Auto Measurements"
          />
          
          {autoMeasureSettings.enabled && (
            <Box sx={{ mt: 1 }}>
              <Typography variant="body2" gutterBottom>
                Confidence Threshold: {Math.round(autoMeasureSettings.confidence * 100)}%
              </Typography>
              <Slider
                value={autoMeasureSettings.confidence}
                onChange={(_, value) => setAutoMeasureSettings(prev => ({
                  ...prev,
                  confidence: value as number
                }))}
                min={0.1}
                max={1.0}
                step={0.1}
                size="small"
              />
              
              <Button
                size="small"
                startIcon={<RefreshIcon />}
                onClick={generateAutoMeasurements}
                sx={{ mt: 1 }}
              >
                Regenerate
              </Button>
            </Box>
          )}
        </Box>

        <Divider sx={{ my: 2 }} />

        {/* CAD Overlay Section */}
        <Box sx={{ mb: 2 }}>
          <FormControlLabel
            control={
              <Switch
                checked={cadSettings.enabled}
                onChange={(e) => setCadSettings(prev => ({
                  ...prev,
                  enabled: e.target.checked
                }))}
              />
            }
            label="CAD Overlays"
          />
          
          {cadSettings.enabled && (
            <Box sx={{ mt: 1 }}>
              <Typography variant="body2" gutterBottom>
                Opacity: {Math.round(cadSettings.opacity * 100)}%
              </Typography>
              <Slider
                value={cadSettings.opacity}
                onChange={(_, value) => setCadSettings(prev => ({
                  ...prev,
                  opacity: value as number
                }))}
                min={0.1}
                max={1.0}
                step={0.1}
                size="small"
              />
            </Box>
          )}
        </Box>

        <Divider sx={{ my: 2 }} />

        {/* Measurements List */}
        <Typography variant="subtitle2" gutterBottom>
          Auto Measurements ({autoMeasurements.length})
        </Typography>
        
        <List dense sx={{ maxHeight: 200, overflow: 'auto' }}>
          {autoMeasurements.map((measurement) => (
            <ListItem key={measurement.id} divider>
              <ListItemText
                primary={measurement.label}
                secondary={`${measurement.value.toFixed(2)} ${measurement.unit} (${Math.round(measurement.metadata.confidence * 100)}%)`}
              />
              <ListItemSecondaryAction>
                <IconButton
                  size="small"
                  onClick={() => handleMeasurementDelete(measurement.id)}
                >
                  <DeleteIcon fontSize="small" />
                </IconButton>
              </ListItemSecondaryAction>
            </ListItem>
          ))}
        </List>

        {/* Detection Summary */}
        <Typography variant="subtitle2" gutterBottom sx={{ mt: 2 }}>
          Detections ({filteredDetections.length})
        </Typography>
        
        <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
          {filteredDetections.slice(0, 5).map((detection) => (
            <Chip
              key={detection.id}
              size="small"
              icon={getSeverityIcon(detection.severity)}
              label={`${detection.class} (${Math.round(detection.confidence * 100)}%)`}
              onClick={() => handleDetectionClick(detection)}
              sx={{
                backgroundColor: `${getSeverityColor(detection.severity)}20`,
                borderColor: getSeverityColor(detection.severity),
                cursor: 'pointer'
              }}
            />
          ))}
          {filteredDetections.length > 5 && (
            <Chip
              size="small"
              label={`+${filteredDetections.length - 5} more`}
              variant="outlined"
            />
          )}
        </Box>
      </Paper>

      {/* Settings Menu */}
      <Menu
        anchorEl={settingsAnchor}
        open={Boolean(settingsAnchor)}
        onClose={handleSettingsClose}
      >
        <MenuItem>
          <FormControlLabel
            control={
              <Switch
                checked={cadSettings.showLabels}
                onChange={(e) => setCadSettings(prev => ({
                  ...prev,
                  showLabels: e.target.checked
                }))}
              />
            }
            label="Show Labels"
          />
        </MenuItem>
        <MenuItem>
          <FormControlLabel
            control={
              <Switch
                checked={cadSettings.showConfidence}
                onChange={(e) => setCadSettings(prev => ({
                  ...prev,
                  showConfidence: e.target.checked
                }))}
              />
            }
            label="Show Confidence"
          />
        </MenuItem>
        <MenuItem>
          <FormControlLabel
            control={
              <Switch
                checked={autoMeasureSettings.autoValidate}
                onChange={(e) => setAutoMeasureSettings(prev => ({
                  ...prev,
                  autoValidate: e.target.checked
                }))}
              />
            }
            label="Auto Validate"
          />
        </MenuItem>
      </Menu>
    </Box>
  );
};

export default AutoMeasurementCADOverlay;